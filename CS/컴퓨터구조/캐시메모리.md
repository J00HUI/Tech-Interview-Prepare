## 캐시 메모리 (Cache Memory)
속도가 빠른 장치와 느린 장치의 속도 차이에 따른 병목 현상을 줄이기 위한 메모리를 말한다.   
</br>

```
ex1) CPU 코어와 메모리 사이의 병목 현상 완화
ex2) 웹 브라우저의 캐시 파일은, 하드디스크와 웹페이지 사이의 병목 현상을 완화
```
</br>

CPU 가 주기억장치에서 저장된 데이터를 읽어올 때, 자주 사용하는 데이터를 캐시 메모리에 저장한 뒤, 다음에 이용할 때 주기억장치가 아닌 캐시 메모리에서 가져오면서 속도를 향상시킨다.   

속도라는 장점을 얻지만, 용량이 적기도 하고 비용이 비싼 점이 있다.   
</br>

CPU 는 이러한 캐시 메모리 2~3 개 정도 사용된다. (L1, L2, L3 캐시 메모리라고 부른다.)   

속도와 크기에 따라 분류한 것으로, 일반적으로 L1 캐시부터 사용된다. (CPU 에서 가장 빠르게 접근하고, 여기서 데이터를 찾지 못하면 L2로 간다.)   
</br>

***듀얼 코어 프로세서의 캐시 메모리*** : 각 코어마다 독립된 L1 캐시 메모리를 가지고, 두 코어가 공유하는 L2 캐시 메모리가 내장된다.   

만약 L1 캐시가 128kb 이면, 64 / 64 로 나누어 64kb 에 명령어를 처리하기 직전의 명령어를 임시 저장하고, 나머지 64kb 에는 실행 후 명령어를 임시저장한다. (명령어 세트로 구성, I-Cache-D-Cache)   

* L1 : CPU 내부에 존재
* L2 : CPU 와 RAM 사이에 존재
* L3 : 보통 메인보드에 존재한다고 함

> 캐시 메모리 크기가 작은 이유는, SRAM 가격이 매우 비쌈   
</br>

***디스크 캐시*** : 주기억장치(RAM)와 보조기억장치(하드디스크) 사이에 존재하는 캐시   
</br>
</br>

**캐시 메모리 작동 원리**
* #### 시간 지역성

  for 나 while 같은 반복문에 사용하는 조건 변수처럼 한 번 참조된 데이터는 잠시후 또 참조될 가능성이 높다.

* #### 공간 지역성

  A[0], A[1] 과 같은 연속 접근 시, 참조된 데이터 근처에 있는 데이터가 잠시 후 또 사용될 가능성이 높다.    
  
> 이처럼 참조 지역성의 원리가 존재한다.   
</br>

캐시에 데이터를 저장할 때는, 이러한 참조 지역성(공간)을 최대한 활용하기 위해 해당 데이터뿐만 아니라, 옆 주소의 데이터도 같이 가져와 미래에 쓰일 것을 대비한다.   

CPU 가 요청한 데이터가 캐시에 있으면 'Cache Hit', 없어서 DRAM 에서 가져오면 'Cache Miss' 라고 한다.
</br>
</br>

#### 캐시 미스 경우 3가지
1. #### Cold miss

    해당 메모리 주소를 처음 불러서 나는 미스   
  
2. #### Conflict miss
    캐시 메모리에 A와 B 데이터를 저장해야 하는데, A와 B가 같은 메모리 주소에 할당되어 있어 나는 미스    
    (direct mapped cache 에서 많이 발생한다.)   
    </br>
   ![image](https://user-images.githubusercontent.com/83942393/218929808-c38565fe-c787-4aa7-ad44-da75735c037c.png)
   </br>
   
   Cache 에서 set 의 way 가 부족하여 발생하는 miss 이다.   
   위 그림에서 다른 주소더라도 index 8bit(초록색)이 같게 되면 같은 세트에 위치한다.   
   이 때문에 우연히 이 세트에 여러번 접근하면 특정 set 에 way 가 부족하여 miss 를 일으키는데 이를 conflict miss 라 한다.   
   
 3. #### Capacity miss

    캐시 메모리의 공간이 부족해서 나는 미스 (Conflict 는 주소 할당 문제, Capacity 는 공간 문제)
    
캐시 **크기를 키워서 문제를 해결하려고 하면, 캐시 접근 속도가 느리고 파워를 많이 먹는 단점**이 발생한다.   




